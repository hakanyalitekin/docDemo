"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1599],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return c}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=o.createContext({}),l=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=l(e.components);return o.createElement(p.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(t),c=r,h=u["".concat(p,".").concat(c)]||u[c]||m[c]||i;return t?o.createElement(h,a(a({ref:n},d),{},{components:t})):o.createElement(h,a({ref:n},d))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,a=new Array(i);a[0]=u;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var l=2;l<i;l++)a[l]=t[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8860:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return p},default:function(){return c},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return m}});var o=t(7462),r=t(3366),i=(t(7294),t(3905)),a=["components"],s={title:"The Framework",description:"Learn what makes the Admin app tick, and how plugins work."},p=void 0,l={unversionedId:"getting-started/test",id:"getting-started/test",title:"The Framework",description:"Learn what makes the Admin app tick, and how plugins work.",source:"@site/docs/getting-started/test.mdx",sourceDirName:"getting-started",slug:"/getting-started/test",permalink:"/docDemo/docs/getting-started/test",editUrl:"https://github.com/hakanyalitekin/docDemo/tree/master/docs/docs/getting-started/test.mdx",tags:[],version:"current",frontMatter:{title:"The Framework",description:"Learn what makes the Admin app tick, and how plugins work."},sidebar:"tutorialSidebar",previous:{title:"Kurulum",permalink:"/docDemo/docs/getting-started/setup"},next:{title:"Tutorial Intro",permalink:"/docDemo/docs/intro"}},d={},m=[{value:"Overview",id:"overview",level:2},{value:"The <code>Provider</code> Component",id:"the-provider-component",level:2},{value:"The <code>Compose</code> Component",id:"the-compose-component",level:2},{value:"The <code>Plugins</code> Component",id:"the-plugins-component",level:2},{value:"The <code>AddRoute</code> Plugin",id:"the-addroute-plugin",level:3},{value:"The <code>AddMenu</code> Plugin",id:"the-addmenu-plugin",level:3},{value:"Naming Conventions",id:"naming-conventions",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:m};function c(e){var n=e.components,t=(0,r.Z)(e,a);return(0,i.kt)("wrapper",(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In order to follow this guide, you must use Webiny version ",(0,i.kt)("strong",{parentName:"p"},"5.21.0")," or greater."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the moving parts of the Admin app framework"),(0,i.kt)("li",{parentName:"ul"},"what is a plugin"),(0,i.kt)("li",{parentName:"ul"},"how the Admin app is rendered")),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Admin app is powered by a simple React framework, which allows you to add new ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/context.html#contextprovider"},"React Context providers"),", compose existing UI components, register routes, and do all that using plain ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/react-component.html"},"React components"),", and widely used concepts, like ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/higher-order-components.html"},"Higher Order Components")," (hereinafter: HOCs), and ",(0,i.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"hooks"),"."),(0,i.kt)("p",null,"In the following sections, we cover 5 fundamental components which make everything work. These 5 components make up the low-level API, and in the vast majority of cases, these are the only components you'll need to use to develop new plugins (besides your own custom components and views)."),(0,i.kt)("p",null,"The following diagram shows all 5 components in action:"),(0,i.kt)("p",null,"As you can see, what you mount, is not exactly what gets rendered. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin")," component (the framework) takes care of rendering things ",(0,i.kt)("em",{parentName:"p"},"where")," and ",(0,i.kt)("em",{parentName:"p"},"when")," they need to be rendered, and also does various compositions and optimizations (caching) in the process."),(0,i.kt)("p",null,"A good example of that are the React Context providers (represented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Provider")," component in the diagram). Traditionally, when using Higher Order Components (HOCs), we end up with a deep hierarchy of nested components, which is hard to read, and even harder to maintain. In these cases, we usually resort to HOC composition, to flatten out the hierarchy, and produce a single component which is constructed of the individual HOCs wrapped around the previous one. We use the same technique to construct React Context providers."),(0,i.kt)("h2",{id:"the-provider-component"},"The ",(0,i.kt)("inlineCode",{parentName:"h2"},"Provider")," Component"),(0,i.kt)("p",null,"When building your own plugins, or entire applications, we often need to add one or more React Context providers to share the state between our components, regardless of their location in the component hierarchy. Now imagine you use 10 third-party (or even your own) plugins, and each plugin has its own React Context provider. How annoying would it be to import those providers individually, and mount them one by one?"),(0,i.kt)("p",null,"We make this easy for you, using our ",(0,i.kt)("inlineCode",{parentName:"p"},"Provider")," component. The component accepts a single HOC, and this allows us to compose providers for you. Here's an example of a simple Provider HOC implementation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'import React, { createContext } from "react";\nimport { Provider } from "@webiny/app-serverless-cms";\n\nconst MyContext = createContext({});\n\nconst MyProviderHOC = (PreviousProvider) => {\n    return function MyProvider({ children }) {\n        const myContext = {\n            /* context value goes here */\n        };\n\n        return (\n            <MyContext.Provider value={myContext}>\n                <PreviousProvider>{children}</PreviousProvider>\n            </MyContext.Provider>\n        );\n    };\n};\n\n// Register a new provider as a child of the <Admin> element\n// NOTE: this can be anywhere in the hierarchy, grouped under a custom plugin component, etc.\nexport const App = () => {\n    return (\n        <Admin>\n            <Provider hoc={MyProviderHOC} />\n        </Admin>\n    );\n};\n')),(0,i.kt)("p",null,"One of the important characteristics of the Provider component is that, by using it, you can't interfere with the core setup of the Webiny Serverless CMS, and break it accidentally. Your Providers will ",(0,i.kt)("em",{parentName:"p"},"always")," be mounted lower in the hierarchy, ",(0,i.kt)("em",{parentName:"p"},"after")," the core Providers."),(0,i.kt)("h2",{id:"the-compose-component"},"The ",(0,i.kt)("inlineCode",{parentName:"h2"},"Compose")," Component"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Compose")," component allows you to wrap (compose) ",(0,i.kt)("em",{parentName:"p"},"existing")," React components, that are ",(0,i.kt)("em",{parentName:"p"},"already used")," in the existing apps, intercept them at runtime, and change the content that gets rendered."),(0,i.kt)("p",null,"A good usage example are the menu items in the main navigation of the Admin app."),(0,i.kt)("p",null,".\nAll the menu items are represented with a single underlying data structure. Depending on menu item's children, depth (menu within a menu), presence of a link (or an onClick callback), etc., different renderers need to be applied."),(0,i.kt)("p",null,"Instead of implementing one giant renderer for the entire navigation, we can compose multiple smaller, single-purpose renderers and let them handle individual cases. This also makes it super easy for you to modify individual renderers if the defaults are not the best fit for your project."),(0,i.kt)("p",null,"Here's a code example to demonstrate the usage of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Compose")," component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},'import React from "react";\n// Import a component you want to compose (in this case, it\'s MenuItemRenderer).\nimport { MenuItemRenderer, useMenuItem } from "@webiny/app-serverless-cms";\nimport { Link } from "@webiny/react-router";\n\n// Implement a HOC to compose with the target component\nconst MyMenuItemRenderer = (OriginalRenderer) => {\n    return function MyMenuItem() {\n        // Use the `useMenuItem` hook to access the current menu item being rendered.\n        const { menuItem, depth } = useMenuItem();\n\n        // Decide whether you want to handle this menu item.\n        const shouldRender = depth === 0 && menuItem.path;\n\n        if (!shouldRender) {\n            // Pass the rendering to the original component.\n            return <OriginalRenderer />;\n        }\n\n        // Render the menu item!\n        return <Link to={menuItem.path}>{menuItem.label}</Link>;\n    };\n};\n\n// Any time a MenuItemRenderer is mounted, you want to apply your component first.\n// NOTE: you can register as many HOCs as you need.\nexport const App = () => {\n    return (\n        <Admin>\n            <Compose component={MenuItemRenderer} with={MyMenuItemRenderer} />\n        </Admin>\n    );\n};\n')),(0,i.kt)("h2",{id:"the-plugins-component"},"The ",(0,i.kt)("inlineCode",{parentName:"h2"},"Plugins")," Component"),(0,i.kt)("p",null,"To explain why we need this component, let's quickly describe what a ",(0,i.kt)("em",{parentName:"p"},"plugin")," is."),(0,i.kt)("p",null,"A plugin is a React component that can do things like adding a route, adding a menu, adding a file type renderer, etc. Plugins can also be composed into larger plugin components, to perform more complex tasks."),(0,i.kt)("p",null,"More often than not, a plugin component needs to access one or more React Contexts provided by various apps (Page Builder, File Manager, etc.), to do its job. To be able to do that, plugin components need to be rendered as children of all those React Context providers (if unsure, revisit the diagram in the ",(0,i.kt)("a",{parentName:"p",href:"#overview"},"Overview")," section)."),(0,i.kt)("p",null,"The purpose of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Plugins")," component is to make sure that its children are rendered at the right place within the app component hierarchy. It helps you not to think about ",(0,i.kt)("em",{parentName:"p"},"where")," you mount your plugin components, so you're more flexible with how you build your custom plugins."),(0,i.kt)("p",null,"You can mount as many ",(0,i.kt)("inlineCode",{parentName:"p"},"<Plugins>")," elements as you need, anywhere in the app components hierarchy. The only important thing is that you ",(0,i.kt)("em",{parentName:"p"},"do")," mount it when you want to add one or more plugins to the app."),(0,i.kt)("p",null,"Here's the simplest, most straightforward example of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Plugins")," component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"Using <Plugins/> to Add Routes and Menus",Using:!0,"<Plugins/>":!0,to:!0,Add:!0,Routes:!0,and:!0,Menus:!0},'import React from "react";\nimport { Admin, Plugins, AddMenu, AddRoute, Layout } from "@webiny/app-serverless-cms";\n\n// Mount everything as children of the <Admin> element.\nexport const App = () => {\n    return (\n        <Admin>\n            <Plugins>\n                <AddMenu id={"myApp"} label={"My App"}>\n                    <AddMenu id={"myApp.records"} label={"Records"} path={"/my-app/records"} />\n                </AddMenu>\n                <AddRoute path={"/my-app/records"}>\n                    <Layout title={"My App - Records"}>{/* Your UI goes here. */}</Layout>\n                </AddRoute>\n            </Plugins>\n        </Admin>\n    );\n};\n')),(0,i.kt)("h3",{id:"the-addroute-plugin"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"AddRoute")," Plugin"),(0,i.kt)("p",null,"This plugin is used to add routes to the Admin app (which we already saw in action, in the previous section). It accepts all the props supported by ",(0,i.kt)("inlineCode",{parentName:"p"},"react-router")," (which we use under the hood), but since it's a plugin, we don't immediately mount the ",(0,i.kt)("inlineCode",{parentName:"p"},"<Route/>"),". Instead, we register the route internally, and then mount it where and when necessary (as shown in the ",(0,i.kt)("a",{parentName:"p",href:"#overview"},"Overview")," section diagram)."),(0,i.kt)("h3",{id:"the-addmenu-plugin"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"AddMenu")," Plugin"),(0,i.kt)("p",null,"This component is used to add navigation menu items, and supports infinite levels of nesting (as long as your menu item renderers can render them). By default, we provide renderers for the navigation shown in the ",(0,i.kt)("a",{parentName:"p",href:"#the-compose-component"},"Compose component")," section."),(0,i.kt)("p",null,"The basic usage is already shown in the ",(0,i.kt)("a",{parentName:"p",href:"#the-plugins-component"},"Plugins component")," section.\nWith that in mind, let's show a more advanced example, and demonstrate how it would work with permission checks:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx",metastring:"Plugin Composition",Plugin:!0,Composition:!0},'import React from "react";\nimport { Admin, Plugins, AddMenu, AddRoute, Layout, HasPermission } from "@webiny/app-serverless-cms";\n\nexport const MyPlugin = () => {\n    return (\n        <Plugins>\n            {/* Only mount the top-level menu element if the user has the required permission. */}\n            <HasPermission name={"myApp"}>\n                <AddMenu id={"myApp"} label={"My App"}>\n                    {/* Only mount sub-menu element and the corresponding route, if the user has the required permission. */}\n                    <HasPermission name={"myApp.records"}>\n                        <AddMenu id={"myApp.records"} label={"Records"} path={"/my-app/records"} />\n                        <AddRoute path={"/my-app/records"}>\n                            <Layout title={"My App - Records"}>{/* Your UI goes here. */}</Layout>\n                        </AddRoute>\n                    </HasPermission>\n                </AddMenu>\n            </HasPermission>\n        </Plugins>\n    );\n};\n\nexport const App = () => {\n    return (\n        <Admin>\n            <MyPlugin />\n        </Admin>\n    );\n};\n')),(0,i.kt)("p",null,"The only hard rule to be aware of is that you ",(0,i.kt)("strong",{parentName:"p"},"must")," mount the ",(0,i.kt)("inlineCode",{parentName:"p"},"<Provider/>")," element ",(0,i.kt)("em",{parentName:"p"},"outside")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"<Plugins/>")," element. ",(0,i.kt)("inlineCode",{parentName:"p"},"<Compose/>")," can go anywhere within the ",(0,i.kt)("inlineCode",{parentName:"p"},"<Admin/>")," element."),(0,i.kt)("h2",{id:"naming-conventions"},"Naming Conventions"),(0,i.kt)("p",null,"There are many components exported from the ",(0,i.kt)("inlineCode",{parentName:"p"},"@webiny/app-serverless-cms")," package. These naming conventions will help you find your way around, and quickly filter out components in your IDE."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"components that ",(0,i.kt)("em",{parentName:"li"},"add")," things to the system start with ",(0,i.kt)("inlineCode",{parentName:"li"},"Add")," prefix (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"AddMenu"),")"),(0,i.kt)("li",{parentName:"ul"},"presentation components end with ",(0,i.kt)("inlineCode",{parentName:"li"},"Renderer")," (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"MenuItemRenderer"),")"),(0,i.kt)("li",{parentName:"ul"},"hooks, by React convention, start with ",(0,i.kt)("inlineCode",{parentName:"li"},"use")," (e.g., ",(0,i.kt)("inlineCode",{parentName:"li"},"useSecurity"),")")),(0,i.kt)("p",null,"Almost always, renderer components go with a parent component that provides a React Context to the renderer. For example, a ",(0,i.kt)("inlineCode",{parentName:"p"},"UserMenuItem")," has a corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"UserMenuItemRenderer")," component. The renderer component doesn't take any props; instead, it uses hooks to fetch the relevant data from React Context, provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"UserMenuItem")," component. This approach drastically reduces prop drilling, and makes it easier to decouple logic from presentation. This topic will be covered in more details in a dedicated article."),(0,i.kt)("p",null,"If you want to change the appearance (the renderer) of a certain component, always look for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Renderer")," part of it, and compose ",(0,i.kt)("em",{parentName:"p"},"that")," component."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"These few simple components is what makes up the core of the Admin app. This provides strong and simple foundations to build upon. It's easily composable, and gives the ability to lazy-load plugins, apply plugins conditionally, compose component renderers, and also compose these atomic components into larger plugins."),(0,i.kt)("p",null,"In the prior versions of Webiny, we relied on a global plugins registry, and plugins as objects. This approach still works, and all your existing plugins will work as if nothing changed."),(0,i.kt)("p",null,"However, the core Webiny apps will slowly be transitioning to this new React based API, and we'll be exposing more plugin components as we go."))}c.isMDXComponent=!0}}]);